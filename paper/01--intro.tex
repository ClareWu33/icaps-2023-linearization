Hierarchical Task Network (HTN) planning, as described by \shortCite{HTNSurvey}, is a hierarchical approach to planning where so-called \emph{compound tasks} are kept being refined until primitive ones (also called \emph{actions}) are obtained which form a \emph{plan}. Research on HTN planning has drawn increasing interests in the last decade due to its expressive power. More concretely, HTN planning can simulate the classes of formal languages ranging from star-free languages to (a strict subset of) context-sensitive languages, whereas non-hierarchical (i.e., classical) planning can only express a strict subset of star-free languages \cite{Hoeller2016Expressivity,Lin2022LTLExpressivity}. % As defined by \cite{HTNSurvey},  %  and \cite{IntroGhallab},
% tasks in HTN planning are either primitive, corresponding to an action that can be taken, or compound. HTN problems have a set of methods that specify how one might achieve a given compound task, by decomposing it into a set of sub-tasks. A compound task may even decompose into itself, either directly via a method, or indirectly via a sequence of method applications. If decomposition leads to a sequence of primitive tasks executable from the initial state, then this sequence of actions is a solution to the problem, also known as a \enquote{plan}. 

One major problem faced by the HTN planning community is the high computational complexity of HTN planning problems. Specifically, \shortCite{Erol1996HTNComplexity} have shown that an HTN planning problem is undecidable in general, and thus, finding a solution to an HTN problem is still a challenge task even for the state-of-the-art HTN planner.

In this paper, we propose a novel approach which transforms a general HTN planning problem (where a compound task is refined into a \emph{partially ordered} set of subtasks) into a \emph{totally ordered} one which is a special form of HTN planning problems and in which a compound task can only be refined into a \emph{sequence} (i.e., a totally ordered set) of subtasks. More importantly, our approach assures that any solution to the transformed problem is also a solution to the original problem, and our approach works for both the grounded and the lifted formalism. Thus, by employing this approach (e.g., as a preprocessor), we could reduce the complexity of finding a solution to the original problem because, as proved by \shortCite{Alford2015TightHTNBounds}, it is \EXPTIME{}-complete to solve a totally ordered HTN planning problem, and specialized HTN planning techniques (e.g., heuristics and pruning techniques) for only totally ordered problems can also be deployed for solving the transformed problem.

Notably, our approach does \emph{not} guarantee that at least one solution will be preserved after the transformation. However, our empirical evaluation shown that it is rarely the case that none solutions are preserved. More specifically, there is only one domain in our benchmark set where problems become unsolvable after the transformation. Additionally, we will also present certain criteria which assert that at least one solution will be preserved if they are satisfied.

As a side contribution, our approach can also be exploited to create new total order HTN planning domains from partial order ones. This might be particularly useful by taking into account the upcoming 2023 International Planning Competition (IPC) on HTN planning.


% In totally ordered HTN planning, or TOHTN planning, methods specify a total order on the sub-tasks. In partially ordered HTN planning, or POHTN planning, methods might only specify a partial order on the sub-tasks. 

% % Certain kinds of problems might be naturally more suited to being modelled as a partially ordered problem, for example, the actions \enquote{deliver package 1 to city A} and \enquote{deliver package 2 to city B} -- these are essentially unrelated goals in a real transport scenario, and so modelling the problem to require that one task be completed before the other would be unnecessarily limiting the possible solution space. For some problems, such over-specification may remove all valid solutions. 

% Many problems might be naturally more suited to being modelled as POHTN problems. However, for \emph{solving} the problem, it is desirable to have additional constraints that reduces the search space, while still preserving at least some of the actual solutions. For example, \cite{ErolHTNExpressivity} proved that POHTN planning is expressive enough to model undecidable problems, such as the language intersection problem of two context-free languages. On the other hand, TOHTN planning is not expressive enough to model undecideable problems. Where this is possible, it results in lower worst-case solving time. Converting the problem to a TOHTN problem allows us to exploit that fact to solve the problem more quickly.

% Another benefit of transforming a POHTN problem to a TOHTN problem is that the additional structure to the problem could allow us to deploy specialised algorithms and heuristics for the totally ordered case. % Also, heuristic design is comparably easy for total-order problems due to the missing interaction between tasks.
% The drawback to this approach is that, due to the greater expressivity of POHTN planning, there may exist POHTN problems that cannot be solved when converted to a TOHTN problem. 
% Fortunately, not every POHTN problem is guaranteed to be undecidable, and so could still be transformed while preserving at least one solution. In fact, the state-of-the-art panda$_\pi$ planner and \cite{HTN2SAS} both use a compilation to classical planning, another decidable planning class.
% In this paper we present and investigate an algorithm for converting POHTN problems to TOHTN problems. We prove that when certain criteria are met, it guarantees that at least one solution will be preserved. 
% Also, we obtain a new class of decidable problems, namely those that satisfy the above mentioned criterion. Finally, we show that, even when these criteria are not met, very few problems are rendered unsolvable by the transformation, and that it greatly reduces solving time for problems, with gains being bigger for more difficult problems. 